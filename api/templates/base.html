<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% block title %}Agent Admin{% endblock %}</title>
  <link rel="stylesheet" href="/static/style.css">
  <script src="https://unpkg.com/htmx.org@2.0.4" integrity="sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.8/dist/cdn.min.js"></script>
  {% block head %}{% endblock %}
</head>
<body class="py-8" style="padding-left: 32px; padding-right: 32px;">
  {% block body %}{% endblock %}

  <div id="toast" style="position: fixed; right: 24px; bottom: 24px; display: none; z-index: 100; max-width: 360px;"></div>

  <script>
    // Global: set HTMX auth header from localStorage
    document.body.addEventListener('htmx:configRequest', function(e) {
      const key = localStorage.getItem('admin_api_key') || '';
      if (key) {
        e.detail.headers['Authorization'] = 'Bearer ' + key;
      }
    });

    document.body.addEventListener('htmx:afterSwap', function(e) {
      if (window.Alpine && e.detail && e.detail.target) {
        window.Alpine.initTree(e.detail.target);
      }
    });

    function showToast(message, ok = true) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.className = ok ? 'alert-success' : 'alert-error';
      toast.style.display = 'block';
      clearTimeout(toast._timer);
      toast._timer = setTimeout(() => {
        toast.style.display = 'none';
      }, 2500);
    }
    window.showToast = showToast;

    function llmTab(provider, apiKey, model, openaiKey, openaiBaseUrl, googleKey, googleBaseUrl, grokKey, grokBaseUrl, deepseekKey, deepseekBaseUrl, extractionProvider, extractionModel, consolidationProvider, consolidationModel) {
      const currentProvider = provider || 'anthropic';
      return {
        providerOptions: [
          {value: 'anthropic', label: 'Anthropic'},
          {value: 'openai', label: 'OpenAI'},
          {value: 'google', label: 'Google Gemini'},
          {value: 'grok', label: 'Grok (xAI)'},
          {value: 'deepseek', label: 'DeepSeek'}
        ],
        provider: currentProvider,
        apiKey: apiKey || '',
        model: model || '',
        openaiKey: openaiKey || '',
        openaiBaseUrl: openaiBaseUrl || '',
        googleKey: googleKey || '',
        googleBaseUrl: googleBaseUrl || '',
        grokKey: grokKey || '',
        grokBaseUrl: grokBaseUrl || '',
        deepseekKey: deepseekKey || '',
        deepseekBaseUrl: deepseekBaseUrl || '',
        extractionProvider: extractionProvider || 'anthropic',
        extractionModel: extractionModel || 'claude-4-5-haiku',
        consolidationProvider: consolidationProvider || 'anthropic',
        consolidationModel: consolidationModel || 'claude-4-5-haiku',
        memoryResult: '',
        memoryResultOk: false,
        result: '',
        resultOk: false,
        tests: {
          anthropic: currentProvider === 'anthropic',
          openai: currentProvider === 'openai',
          google: currentProvider === 'google',
          grok: currentProvider === 'grok',
          deepseek: currentProvider === 'deepseek'
        },
        testing: {
          anthropic: false,
          openai: false,
          google: false,
          grok: false,
          deepseek: false
        },
        testResults: {
          anthropic: '',
          openai: '',
          google: '',
          grok: '',
          deepseek: ''
        },
        models: {
          anthropic: [
            {value: 'claude-4-6-opus', label: 'claude-4-6-opus'},
            {value: 'claude-4-6-sonnet', label: 'claude-4-6-sonnet'},
            {value: 'claude-4-5-haiku', label: 'claude-4-5-haiku'}
          ],
          openai: [
            {value: 'gpt-5.2-thinking', label: 'gpt-5.2-thinking'},
            {value: 'gpt-5.2-pro', label: 'gpt-5.2-pro'},
            {value: 'gpt-5.2-instant', label: 'gpt-5.2-instant'},
            {value: 'gpt-5-mini', label: 'gpt-5-mini'}
          ],
          google: [
            {value: 'gemini-deep-think-latest', label: 'gemini-deep-think-latest'},
            {value: 'gemini-pro-latest', label: 'gemini-pro-latest'},
            {value: 'gemini-flash-latest', label: 'gemini-flash-latest'}
          ],
          grok: [
            {value: 'grok-4.20-beta', label: 'grok-4.20-beta'},
            {value: 'grok-4-latest', label: 'grok-4-latest'},
            {value: 'grok-4.1-fast', label: 'grok-4.1-fast'}
          ],
          deepseek: [
            {value: 'deepseek-chat', label: 'deepseek-chat'},
            {value: 'deepseek-reasoner', label: 'deepseek-reasoner'}
          ]
        },
        init() {
          const savedProvider = this.provider;
          // Preserve the server-provided values after Alpine's x-for has
          // rendered the <option> elements â€” without this the browser
          // resets <select> to the first option before options exist.
          const savedModel = this.model;
          const savedExtraction = this.extractionModel;
          const savedConsolidation = this.consolidationModel;
          this.$nextTick(() => {
            const validProvider = this.providerOptions.some(item => item.value === savedProvider);
            this.provider = validProvider ? savedProvider : 'anthropic';
            this.model = savedModel;
            this.extractionModel = savedExtraction;
            this.consolidationModel = savedConsolidation;
            this.resetModel();
            this.resetMemoryModel('extraction');
            this.resetMemoryModel('consolidation');
          });
        },
        resetModel() {
          const list = this.models[this.provider] || [];
          if (!list.length) return;
          const current = this.model || '';
          const isValid = list.some(item => item.value === current);
          if (!isValid) { this.model = list[0].value; }
        },
        resetMemoryModel(kind) {
          const prov = kind === 'extraction' ? this.extractionProvider : this.consolidationProvider;
          const list = this.models[prov] || [];
          if (!list.length) return;
          if (kind === 'extraction') {
            const current = this.extractionModel || '';
            if (!list.some(item => item.value === current)) {
              this.extractionModel = list[0].value;
            }
            return;
          }
          const current = this.consolidationModel || '';
          if (!list.some(item => item.value === current)) {
            this.consolidationModel = list[0].value;
          }
        },
        keyFor(service) {
          if (service === 'openai') return this.openaiKey;
          if (service === 'google') return this.googleKey;
          if (service === 'grok') return this.grokKey;
          if (service === 'deepseek') return this.deepseekKey;
          return this.apiKey;
        },
        baseUrlFor(service) {
          if (service === 'openai') return this.openaiBaseUrl;
          if (service === 'google') return this.googleBaseUrl;
          if (service === 'grok') return this.grokBaseUrl;
          if (service === 'deepseek') return this.deepseekBaseUrl;
          return '';
        },
        resolvedBaseUrl(service) {
          const base = this.baseUrlFor(service);
          if (service === 'google') return base || 'https://generativelanguage.googleapis.com/v1beta/openai';
          if (service === 'grok') return base || 'https://api.x.ai/v1';
          if (service === 'deepseek') return base || 'https://api.deepseek.com';
          return base;
        },
        canSelect(service) {
          return this.tests[service] === true;
        },
        testProvider(service) {
          const apiKey = this.keyFor(service);
          if (!apiKey) {
            this.tests[service] = false;
            this.testResults[service] = 'Missing API key';
            return;
          }
          this.testing[service] = true;
          this.testResults[service] = '';
          fetch('/setup/test-connection', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({
              service: service,
              api_key: apiKey,
              base_url: this.resolvedBaseUrl(service) || undefined
            })
          })
            .then(r => r.json())
            .then(d => {
              this.tests[service] = !!d.ok;
              this.testResults[service] = d.ok
                ? 'Connection OK'
                : ('Failed: ' + (d.error || 'unknown'));
            })
            .catch(e => {
              this.tests[service] = false;
              this.testResults[service] = 'Error: ' + e.message;
            })
            .finally(() => {
              this.testing[service] = false;
            });
        }
      };
    }
    window.llmTab = llmTab;

    function searchTab(enabled, provider, apiKey, maxResults) {
      return {
        enabled: enabled ?? 'false',
        provider: provider || 'tavily',
        apiKey: apiKey || '',
        maxResults: maxResults || '5',
        result: '',
        resultOk: false,
        testing: false,
        testResult: ''
      };
    }
    window.searchTab = searchTab;

    function calendarTab(providers, googleConnected, googleClientId, hasOAuthCreds) {
      const list = Array.isArray(providers) ? providers : [];
      return {
        providers: list.map((p, idx) => ({
          id: p.id || String(Date.now() + idx),
          name: p.name || '',
          url: p.url || '',
          username: p.username || '',
          password: p.password || ''
        })),
        status: '',
        result: '',
        ok: false,
        // Google OAuth state
        googleConnected: !!googleConnected,
        oauthClientId: googleClientId || '',
        oauthClientSecret: '',
        hasOAuthCreds: !!hasOAuthCreds,
        oauthStatus: '',
        oauthResult: '',
        oauthOk: false,

        addProvider() {
          this.providers.push({
            id: String(Date.now() + Math.random()),
            name: '',
            url: '',
            username: '',
            password: ''
          });
        },
        removeProvider(index) {
          this.providers.splice(index, 1);
        },

        saveOAuthCreds() {
          this.oauthStatus = 'Saving...';
          this.oauthResult = '';
          fetch('/calendar/google/oauth/save-credentials', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({
              client_id: this.oauthClientId.trim(),
              client_secret: this.oauthClientSecret.trim()
            })
          })
            .then(r => r.json())
            .then(data => {
              if (data.ok) {
                this.hasOAuthCreds = true;
                this.oauthOk = true;
                this.oauthResult = 'OAuth credentials saved';
                this.oauthStatus = '';
                if (window.showToast) { window.showToast('OAuth credentials saved'); }
              } else {
                this.oauthOk = false;
                this.oauthResult = data.detail || data.error || 'Save failed';
                this.oauthStatus = '';
              }
            })
            .catch(e => {
              this.oauthOk = false;
              this.oauthResult = e.message || 'Network error';
              this.oauthStatus = '';
            });
        },

        connectGoogle() {
          this.oauthStatus = 'Starting OAuth flow...';
          this.oauthResult = '';
          const self = this;

          // Listen for postMessage from the OAuth popup
          function onMessage(event) {
            if (event.data && event.data.type === 'google-oauth-success') {
              self.googleConnected = true;
              self.oauthOk = true;
              self.oauthResult = 'Google Calendar connected!';
              self.oauthStatus = '';
              if (window.showToast) { window.showToast('Google Calendar connected!'); }
              window.removeEventListener('message', onMessage);
            } else if (event.data && event.data.type === 'google-oauth-error') {
              self.oauthOk = false;
              self.oauthResult = 'Authorization failed: ' + (event.data.error || 'unknown');
              self.oauthStatus = '';
              window.removeEventListener('message', onMessage);
            }
          }
          window.addEventListener('message', onMessage);

          fetch('/calendar/google/oauth/start', {
            headers: {
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            }
          })
            .then(r => r.json())
            .then(data => {
              if (data.auth_url) {
                this.oauthStatus = 'Waiting for Google authorization...';
                window.open(data.auth_url, 'google-oauth', 'width=600,height=700');
              } else {
                this.oauthOk = false;
                this.oauthResult = data.detail || 'Failed to start OAuth flow';
                this.oauthStatus = '';
                window.removeEventListener('message', onMessage);
              }
            })
            .catch(e => {
              this.oauthOk = false;
              this.oauthResult = e.message || 'Network error';
              this.oauthStatus = '';
              window.removeEventListener('message', onMessage);
            });
        },

        saveProviders() {
          this.status = 'Saving...';
          const cleaned = this.providers
            .map(p => ({
              name: (p.name || '').trim(),
              url: (p.url || '').trim(),
              username: (p.username || '').trim(),
              password: (p.password || '').trim()
            }))
            .filter(p => p.name || p.url || p.username || p.password);
          const url = new URL('/calendar/providers', window.location.origin);
          fetch(url.toString(), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            credentials: 'same-origin',
            body: JSON.stringify({providers: cleaned})
          })
            .then(async r => {
              const text = await r.text();
              let data = {};
              try {
                data = text ? JSON.parse(text) : {};
              } catch (err) {
                data = {error: text || 'Invalid response'};
              }
              return {ok: r.ok, data};
            })
            .then(({ok, data}) => {
              this.ok = ok && data.ok;
              this.result = this.ok ? 'Calendars saved' : (data.error || 'Save failed');
              this.status = '';
              if (this.ok && window.showToast) { window.showToast('Calendars saved'); }
            })
            .catch(e => {
              this.ok = false;
              this.result = e.message || 'Network error';
              this.status = '';
            });
        }
      };
    }
    window.calendarTab = calendarTab;

    function contactsTab(providers) {
      const list = Array.isArray(providers) ? providers : [];
      return {
        providers: list.map((p, idx) => ({
          id: p.id || String(Date.now() + idx),
          name: p.name || '',
          type: p.type || 'carddav',
          url: p.url || '',
          username: p.username || '',
          password: p.password || '',
          client_id: p.client_id || '',
          client_secret: p.client_secret || '',
          oauth_status: ''
        })),
        status: '',
        result: '',
        ok: false,
        addProvider() {
          this.providers.push({
            id: String(Date.now() + Math.random()),
            name: '',
            type: 'carddav',
            url: '',
            username: '',
            password: '',
            client_id: '',
            client_secret: ''
          });
        },
        removeProvider(index) {
          this.providers.splice(index, 1);
        },
        saveProviders() {
          this.status = 'Saving...';
          const cleaned = this.providers
            .map(p => ({
              name: (p.name || '').trim(),
              type: (p.type || 'carddav').trim(),
              url: (p.url || '').trim(),
              username: (p.username || '').trim(),
              password: (p.password || '').trim(),
              client_id: (p.client_id || '').trim(),
              client_secret: (p.client_secret || '').trim()
            }))
            .filter(p => p.name || p.url || p.username || p.password || p.client_id || p.client_secret);
          fetch('/contacts/providers', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({providers: cleaned})
          })
            .then(async r => {
              const text = await r.text();
              let data = {};
              try {
                data = text ? JSON.parse(text) : {};
              } catch (err) {
                data = {error: text || 'Invalid response'};
              }
              return {ok: r.ok, data};
            })
            .then(({ok, data}) => {
              this.ok = ok && data.ok;
              this.result = this.ok ? 'Contacts saved' : (data.error || 'Save failed');
              this.status = '';
              if (this.ok && window.showToast) { window.showToast('Contacts saved'); }
            })
            .catch(e => {
              this.ok = false;
              this.result = e.message || 'Network error';
              this.status = '';
            });
        }
        ,
        startGoogleOAuth(provider) {
          if (!provider || !provider.client_id || !provider.client_secret) {
            this.ok = false;
            this.result = 'Google client ID and secret are required.';
            return;
          }
          provider.oauth_status = 'Starting OAuth...';
          fetch('/calendar/google/oauth/save-credentials', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({client_id: provider.client_id, client_secret: provider.client_secret})
          })
            .then(r => r.json())
            .then(d => {
              if (!d || d.ok !== true) {
                throw new Error(d.error || 'Failed to save OAuth credentials');
              }
              return fetch('/contacts/google/oauth/start', {
                headers: {
                  'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
                }
              });
            })
            .then(r => r.json())
            .then(d => {
              if (!d || !d.auth_url) {
                throw new Error(d.error || 'Missing auth URL');
              }
              const w = window.open(d.auth_url, 'google-oauth', 'width=600,height=720');
              if (!w) {
                throw new Error('Popup blocked. Allow popups to continue.');
              }
              provider.oauth_status = 'Waiting for Google authorization...';
              const handler = (evt) => {
                if (!evt || !evt.data || typeof evt.data.type !== 'string') return;
                if (evt.data.type === 'google-oauth-success') {
                  provider.oauth_status = 'Connected.';
                  window.removeEventListener('message', handler);
                }
                if (evt.data.type === 'google-oauth-error') {
                  provider.oauth_status = evt.data.error || 'Authorization failed.';
                  window.removeEventListener('message', handler);
                }
              };
              window.addEventListener('message', handler);
            })
            .catch(e => {
              provider.oauth_status = e.message || 'OAuth failed.';
            });
        }
      };
    }
    window.contactsTab = contactsTab;

    function emailTab(providers) {
      const list = Array.isArray(providers) ? providers : [];
      return {
        providers: list.map((p, idx) => ({
          id: p.id || String(Date.now() + idx),
          name: p.name || '',
          email: p.email || '',
          display_name: p.display_name || '',
          imap_host: p.imap_host || '',
          imap_port: p.imap_port || '993',
          smtp_host: p.smtp_host || '',
          smtp_port: p.smtp_port || '465',
          login: p.login || '',
          password: p.password || ''
        })),
        status: '',
        result: '',
        resultOk: false,

        addProvider() {
          this.providers.push({
            id: String(Date.now() + Math.random()),
            name: '',
            email: '',
            display_name: '',
            imap_host: '',
            imap_port: '993',
            smtp_host: '',
            smtp_port: '465',
            login: '',
            password: ''
          });
        },
        removeProvider(index) {
          this.providers.splice(index, 1);
        },

        saveProviders() {
          this.status = 'Saving...';
          this.result = '';
          const cleaned = this.providers
            .map(p => ({
              name: (p.name || '').trim(),
              email: (p.email || '').trim(),
              display_name: (p.display_name || '').trim(),
              imap_host: (p.imap_host || '').trim(),
              imap_port: (p.imap_port || '993').toString().trim(),
              smtp_host: (p.smtp_host || '').trim(),
              smtp_port: (p.smtp_port || '465').toString().trim(),
              login: (p.login || '').trim(),
              password: (p.password || '').trim()
            }))
            .filter(p => p.name || p.email || p.imap_host || p.smtp_host);
          fetch('/email/providers', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            credentials: 'same-origin',
            body: JSON.stringify({providers: cleaned})
          })
            .then(async r => {
              const text = await r.text();
              let data = {};
              try { data = text ? JSON.parse(text) : {}; } catch (err) { data = {error: text || 'Invalid response'}; }
              return {ok: r.ok, data};
            })
            .then(({ok, data}) => {
              this.resultOk = ok && data.ok;
              this.result = this.resultOk ? 'Email accounts saved' : (data.error || data.detail || 'Save failed');
              this.status = '';
              if (this.resultOk && window.showToast) { window.showToast('Email accounts saved'); }
            })
            .catch(e => {
              this.resultOk = false;
              this.result = e.message || 'Network error';
              this.status = '';
            });
        }
      };
    }
    window.emailTab = emailTab;

    // Global: handle 401 by redirecting to auth gate
    document.body.addEventListener('htmx:responseError', function(e) {
      if (e.detail.xhr.status === 401) {
        window.location.href = '/login';
      }
    });
  </script>
  {% block scripts %}{% endblock %}
</body>
</html>
