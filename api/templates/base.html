<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% block title %}Agent Admin{% endblock %}</title>
  <link rel="stylesheet" href="/static/style.css">
  <script src="https://unpkg.com/htmx.org@2.0.4" integrity="sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.8/dist/cdn.min.js"></script>
  {% block head %}{% endblock %}
</head>
<body class="py-8" style="padding-left: 32px; padding-right: 32px;">
  {% block body %}{% endblock %}

  <div id="toast" style="position: fixed; right: 24px; bottom: 24px; display: none; z-index: 100; max-width: 360px;"></div>

  <script>
    // Global: set HTMX auth header from localStorage
    document.body.addEventListener('htmx:configRequest', function(e) {
      const key = localStorage.getItem('admin_api_key') || '';
      if (key) {
        e.detail.headers['Authorization'] = 'Bearer ' + key;
      }
    });

    document.body.addEventListener('htmx:afterSwap', function(e) {
      if (window.Alpine && e.detail && e.detail.target) {
        window.Alpine.initTree(e.detail.target);
      }
    });

    function showToast(message, ok = true) {
      const toast = document.getElementById('toast');
      if (!toast) return;
      toast.textContent = message;
      toast.className = ok ? 'alert-success' : 'alert-error';
      toast.style.display = 'block';
      clearTimeout(toast._timer);
      toast._timer = setTimeout(() => {
        toast.style.display = 'none';
      }, 2500);
    }
    window.showToast = showToast;

    function llmTab(provider, apiKey, model, openaiKey, openaiBaseUrl, googleKey, googleBaseUrl, grokKey, grokBaseUrl, deepseekKey, deepseekBaseUrl, extractionProvider, extractionModel, consolidationProvider, consolidationModel) {
      const currentProvider = provider || 'anthropic';
      return {
        provider: currentProvider,
        apiKey: apiKey || '',
        model: model || '',
        customModel: '',
        openaiKey: openaiKey || '',
        openaiBaseUrl: openaiBaseUrl || '',
        googleKey: googleKey || '',
        googleBaseUrl: googleBaseUrl || '',
        grokKey: grokKey || '',
        grokBaseUrl: grokBaseUrl || '',
        deepseekKey: deepseekKey || '',
        deepseekBaseUrl: deepseekBaseUrl || '',
        extractionProvider: extractionProvider || 'anthropic',
        extractionModel: extractionModel || 'claude-4-5-haiku',
        extractionCustomModel: '',
        consolidationProvider: consolidationProvider || 'anthropic',
        consolidationModel: consolidationModel || 'claude-4-5-haiku',
        consolidationCustomModel: '',
        memoryResult: '',
        memoryResultOk: false,
        result: '',
        resultOk: false,
        tests: {
          anthropic: currentProvider === 'anthropic',
          openai: currentProvider === 'openai',
          google: currentProvider === 'google',
          grok: currentProvider === 'grok',
          deepseek: currentProvider === 'deepseek'
        },
        testing: {
          anthropic: false,
          openai: false,
          google: false,
          grok: false,
          deepseek: false
        },
        testResults: {
          anthropic: '',
          openai: '',
          google: '',
          grok: '',
          deepseek: ''
        },
        models: {
          anthropic: [
            {value: 'claude-4-6-opus', label: 'Claude 4.6 Opus'},
            {value: 'claude-4-6-sonnet', label: 'Claude 4.6 Sonnet'},
            {value: 'claude-4-5-haiku', label: 'Claude 4.5 Haiku'}
          ],
          openai: [
            {value: 'gpt-5.2-thinking', label: 'GPT-5.2 Thinking'},
            {value: 'gpt-5.2-pro', label: 'GPT-5.2 Pro'},
            {value: 'gpt-5.2-instant', label: 'GPT-5.2 Instant'},
            {value: 'gpt-5-mini', label: 'GPT-5 Mini'}
          ],
          google: [
            {value: 'gemini-deep-think-latest', label: 'Gemini Deep Think Latest'},
            {value: 'gemini-pro-latest', label: 'Gemini Pro Latest'},
            {value: 'gemini-flash-latest', label: 'Gemini Flash Latest'}
          ],
          grok: [
            {value: 'grok-4.20-beta', label: 'Grok 4.20 Beta'},
            {value: 'grok-4-latest', label: 'Grok 4 Latest'},
            {value: 'grok-4.1-fast', label: 'Grok 4.1 Fast'}
          ],
          deepseek: [
            {value: 'deepseek-v4', label: 'DeepSeek V4'},
            {value: 'deepseek-r1-latest', label: 'DeepSeek R1 Latest'},
            {value: 'deepseek-vl2-latest', label: 'DeepSeek VL2 Latest'}
          ]
        },
        init() {
          this.normalizeModel();
          this.$watch('provider', () => this.normalizeModel());
          this.normalizeMemoryModel('extraction');
          this.normalizeMemoryModel('consolidation');
          this.$watch('extractionProvider', () => this.normalizeMemoryModel('extraction'));
          this.$watch('consolidationProvider', () => this.normalizeMemoryModel('consolidation'));
        },
        normalizeModel() {
          const list = this.models[this.provider] || [];
          if (!list.length) return;
          const current = (this.model || '').trim();
          const exists = current && list.some(item => item.value === current);
          if (exists) {
            this.customModel = '';
          } else {
            this.model = list[0].value;
            this.customModel = '';
          }
        },
        normalizeMemoryModel(kind) {
          const prov = kind === 'extraction' ? this.extractionProvider : this.consolidationProvider;
          const list = this.models[prov] || [];
          if (!list.length) return;
          const current = (kind === 'extraction' ? this.extractionModel : this.consolidationModel) || '';
          const trimmed = current.trim();
          const exists = trimmed && list.some(item => item.value === trimmed);
          if (exists) {
            if (kind === 'extraction') { this.extractionCustomModel = ''; }
            else { this.consolidationCustomModel = ''; }
          } else {
            if (kind === 'extraction') { this.extractionModel = list[0].value; this.extractionCustomModel = ''; }
            else { this.consolidationModel = list[0].value; this.consolidationCustomModel = ''; }
          }
        },
        keyFor(service) {
          if (service === 'openai') return this.openaiKey;
          if (service === 'google') return this.googleKey;
          if (service === 'grok') return this.grokKey;
          if (service === 'deepseek') return this.deepseekKey;
          return this.apiKey;
        },
        baseUrlFor(service) {
          if (service === 'openai') return this.openaiBaseUrl;
          if (service === 'google') return this.googleBaseUrl;
          if (service === 'grok') return this.grokBaseUrl;
          if (service === 'deepseek') return this.deepseekBaseUrl;
          return '';
        },
        resolvedBaseUrl(service) {
          const base = this.baseUrlFor(service);
          if (service === 'google') return base || 'https://generativelanguage.googleapis.com/v1beta/openai';
          if (service === 'grok') return base || 'https://api.x.ai/v1';
          if (service === 'deepseek') return base || 'https://api.deepseek.com';
          return base;
        },
        canSelect(service) {
          return this.tests[service] === true;
        },
        testProvider(service) {
          const apiKey = this.keyFor(service);
          if (!apiKey) {
            this.tests[service] = false;
            this.testResults[service] = 'Missing API key';
            return;
          }
          this.testing[service] = true;
          this.testResults[service] = '';
          fetch('/setup/test-connection', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({
              service: service,
              api_key: apiKey,
              base_url: this.resolvedBaseUrl(service) || undefined
            })
          })
            .then(r => r.json())
            .then(d => {
              this.tests[service] = !!d.ok;
              this.testResults[service] = d.ok
                ? 'Connection OK'
                : ('Failed: ' + (d.error || 'unknown'));
            })
            .catch(e => {
              this.tests[service] = false;
              this.testResults[service] = 'Error: ' + e.message;
            })
            .finally(() => {
              this.testing[service] = false;
            });
        }
      };
    }
    window.llmTab = llmTab;

    function searchTab(enabled, provider, apiKey, maxResults) {
      return {
        enabled: enabled ?? 'false',
        provider: provider || 'tavily',
        apiKey: apiKey || '',
        maxResults: maxResults || '5',
        result: '',
        resultOk: false,
        testing: false,
        testResult: ''
      };
    }
    window.searchTab = searchTab;

    function calendarTab(providers) {
      const list = Array.isArray(providers) ? providers : [];
      return {
        providers: list.map((p, idx) => ({
          id: p.id || String(Date.now() + idx),
          name: p.name || '',
          url: p.url || '',
          username: p.username || '',
          password: p.password || ''
        })),
        status: '',
        result: '',
        ok: false,
        addProvider() {
          this.providers.push({
            id: String(Date.now() + Math.random()),
            name: '',
            url: '',
            username: '',
            password: ''
          });
        },
        removeProvider(index) {
          this.providers.splice(index, 1);
        },
        saveProviders() {
          this.status = 'Saving...';
          const cleaned = this.providers
            .map(p => ({
              name: (p.name || '').trim(),
              url: (p.url || '').trim(),
              username: (p.username || '').trim(),
              password: (p.password || '').trim()
            }))
            .filter(p => p.name || p.url || p.username || p.password);
          const url = new URL('/calendar/providers', window.location.origin);
          fetch(url.toString(), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            credentials: 'same-origin',
            body: JSON.stringify({providers: cleaned})
          })
            .then(async r => {
              const text = await r.text();
              let data = {};
              try {
                data = text ? JSON.parse(text) : {};
              } catch (err) {
                data = {error: text || 'Invalid response'};
              }
              return {ok: r.ok, data};
            })
            .then(({ok, data}) => {
              this.ok = ok && data.ok;
              this.result = this.ok ? 'Calendars saved' : (data.error || 'Save failed');
              this.status = '';
              if (this.ok && window.showToast) { window.showToast('Calendars saved'); }
            })
            .catch(e => {
              this.ok = false;
              this.result = e.message || 'Network error';
              this.status = '';
            });
        }
      };
    }
    window.calendarTab = calendarTab;

    function emailTab(toml) {
      return {
        toml: toml || '',
        result: '',
        resultOk: false,
        save() {
          fetch('/config', {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + (localStorage.getItem('admin_api_key') || '')
            },
            body: JSON.stringify({values: {'email.himalaya.toml': this.toml}})
          })
            .then(r => { this.resultOk = r.ok; return r.json(); })
            .then(d => {
              this.result = this.resultOk ? 'Email config saved' : (d.detail || 'Error');
              if (this.resultOk && window.showToast) { window.showToast('Email config saved'); }
            })
            .catch(e => { this.resultOk = false; this.result = e.message; });
        }
      };
    }
    window.emailTab = emailTab;

    // Global: handle 401 by redirecting to auth gate
    document.body.addEventListener('htmx:responseError', function(e) {
      if (e.detail.xhr.status === 401) {
        window.location.href = '/login';
      }
    });
  </script>
  {% block scripts %}{% endblock %}
</body>
</html>
